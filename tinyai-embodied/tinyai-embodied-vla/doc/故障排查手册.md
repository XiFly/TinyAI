# TinyAI VLA æ•…éšœæ’æŸ¥æ‰‹å†Œ

> å¿«é€Ÿè¯Šæ–­å’Œè§£å†³VLAæ¨¡å—å¸¸è§é—®é¢˜çš„å®ç”¨æŒ‡å—

## ğŸ“‹ ç›®å½•

- [1. è®­ç»ƒé—®é¢˜](#1-è®­ç»ƒé—®é¢˜)
- [2. æ¨ç†é—®é¢˜](#2-æ¨ç†é—®é¢˜)
- [3. æ€§èƒ½é—®é¢˜](#3-æ€§èƒ½é—®é¢˜)
- [4. å†…å­˜é—®é¢˜](#4-å†…å­˜é—®é¢˜)
- [5. æ•°æ®é—®é¢˜](#5-æ•°æ®é—®é¢˜)
- [6. ç¯å¢ƒé—®é¢˜](#6-ç¯å¢ƒé—®é¢˜)
- [7. éƒ¨ç½²é—®é¢˜](#7-éƒ¨ç½²é—®é¢˜)
- [8. æ—¥å¿—åˆ†æ](#8-æ—¥å¿—åˆ†æ)

---

## 1. è®­ç»ƒé—®é¢˜

### é—®é¢˜1.1: æŸå¤±ä¸ä¸‹é™ / NaN

**ç—‡çŠ¶**:
```
Training Episode 10 - Loss: 5.234
Training Episode 20 - Loss: 5.189
Training Episode 30 - Loss: 5.201
Training Episode 40 - Loss: NaN
```

**å¯èƒ½åŸå› åŠè§£å†³æ–¹æ¡ˆ**:

#### åŸå› A: å­¦ä¹ ç‡è¿‡å¤§

**è¯Šæ–­**:
```java
// æ£€æŸ¥å­¦ä¹ ç‡
System.out.println("Current Learning Rate: " + learner.getLearningRate());
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// é™ä½å­¦ä¹ ç‡
learner.setLearningRate(0.0001);  // åŸæ¥æ˜¯0.001

// æˆ–ä½¿ç”¨æ¢¯åº¦è£å‰ª
double maxGradNorm = 1.0;
agent.clipGradients(maxGradNorm);
```

---

#### åŸå› B: æ•°å€¼ä¸ç¨³å®š

**è¯Šæ–­**:
```java
// æ£€æŸ¥è¾“å…¥æ•°æ®èŒƒå›´
public void checkDataRange(NdArray data) {
    double min = data.min();
    double max = data.max();
    System.out.printf("Data range: [%.2f, %.2f]%n", min, max);
    
    // æ£€æŸ¥æ˜¯å¦æœ‰NaNæˆ–Inf
    if (data.hasNaN()) {
        System.err.println("WARNING: Data contains NaN!");
    }
    if (data.hasInf()) {
        System.err.println("WARNING: Data contains Inf!");
    }
}
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// æ·»åŠ æ•°å€¼ç¨³å®šæ€§å¤„ç†
public NdArray softmax(NdArray logits) {
    // å‡å»æœ€å¤§å€¼ï¼Œé˜²æ­¢expæº¢å‡º
    NdArray maxLogits = logits.max(keepdims=true);
    NdArray expLogits = logits.sub(maxLogits).exp();
    
    // æ·»åŠ å°å¸¸æ•°ï¼Œé˜²æ­¢é™¤é›¶
    NdArray sumExp = expLogits.sum(keepdims=true).add(NdArray.of(1e-8));
    
    return expLogits.div(sumExp);
}
```

---

#### åŸå› C: æ‰¹å½’ä¸€åŒ–é—®é¢˜

**è¯Šæ–­**:
```java
// æ£€æŸ¥æ˜¯å¦æ­£ç¡®è®¾ç½®è®­ç»ƒ/è¯„ä¼°æ¨¡å¼
System.out.println("Model mode: " + (agent.isTraining() ? "Training" : "Eval"));
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// è®­ç»ƒæ—¶
agent.train();  // è®¾ç½®ä¸ºè®­ç»ƒæ¨¡å¼

// è¯„ä¼°æ—¶
agent.eval();  // è®¾ç½®ä¸ºè¯„ä¼°æ¨¡å¼
```

---

### é—®é¢˜1.2: è®­ç»ƒé€Ÿåº¦è¿‡æ…¢

**ç—‡çŠ¶**:
```
Episode 1 completed in 45 seconds
Episode 2 completed in 47 seconds
Average: ~46 seconds per episode
(Expected: ~5 seconds per episode)
```

**å¯èƒ½åŸå› åŠè§£å†³æ–¹æ¡ˆ**:

#### åŸå› A: æ‰¹æ¬¡å¤§å°å¤ªå°

**è¯Šæ–­**:
```java
System.out.println("Current batch size: " + config.getBatchSize());
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// å¢å¤§æ‰¹æ¬¡å¤§å°
config.setBatchSize(64);  // åŸæ¥æ˜¯8

// å¦‚æœå†…å­˜ä¸è¶³ï¼Œä½¿ç”¨æ¢¯åº¦ç´¯ç§¯
int accumulationSteps = 8;
int microBatchSize = 8;
// ç­‰æ•ˆæ‰¹æ¬¡å¤§å° = 8 * 8 = 64
```

---

#### åŸå› B: æ•°æ®åŠ è½½ç“¶é¢ˆ

**è¯Šæ–­**:
```java
long startTime = System.currentTimeMillis();
VLAState state = env.reset();
long endTime = System.currentTimeMillis();
System.out.println("Data loading time: " + (endTime - startTime) + "ms");
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// ä½¿ç”¨æ•°æ®é¢„åŠ è½½
ExecutorService dataLoader = Executors.newFixedThreadPool(2);

Future<VLAState> nextState = dataLoader.submit(() -> env.reset());

// åœ¨è®­ç»ƒçš„åŒæ—¶åŠ è½½ä¸‹ä¸€ä¸ªæ•°æ®
VLAState currentState = nextState.get();
nextState = dataLoader.submit(() -> env.reset());
```

---

#### åŸå› C: å†—ä½™è®¡ç®—

**è¯Šæ–­**:
```java
// ä½¿ç”¨æ€§èƒ½åˆ†æ
Profiler profiler = new Profiler();
profiler.start("forward_pass");
agent.forward(state);
profiler.stop("forward_pass");

profiler.start("backward_pass");
agent.backward(loss);
profiler.stop("backward_pass");

profiler.printStats();
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// ç¼“å­˜ä¸å˜çš„ç‰¹å¾
private Map<String, NdArray> languageFeatureCache = new HashMap<>();

public NdArray encodeLanguage(String instruction) {
    if (languageFeatureCache.containsKey(instruction)) {
        return languageFeatureCache.get(instruction);
    }
    
    NdArray features = languageEncoder.encode(instruction);
    languageFeatureCache.put(instruction, features);
    return features;
}
```

---

### é—®é¢˜1.3: æ¨¡å‹è¿‡æ‹Ÿåˆ

**ç—‡çŠ¶**:
```
Training Reward: 95.2  âœ“
Validation Reward: 32.5  âœ—
(è®­ç»ƒé›†è¡¨ç°å¥½ï¼ŒéªŒè¯é›†è¡¨ç°å·®)
```

**å¯èƒ½åŸå› åŠè§£å†³æ–¹æ¡ˆ**:

#### åŸå› A: è®­ç»ƒæ•°æ®ä¸å¤Ÿå¤šæ ·åŒ–

**è¯Šæ–­**:
```java
// æ£€æŸ¥ç¯å¢ƒéšæœºæ€§
public void checkEnvironmentDiversity() {
    Set<String> uniqueStates = new HashSet<>();
    
    for (int i = 0; i < 100; i++) {
        VLAState state = env.reset();
        uniqueStates.add(state.toString());
    }
    
    System.out.println("Unique states: " + uniqueStates.size() + " / 100");
    // å¦‚æœ < 50ï¼Œè¯´æ˜å¤šæ ·æ€§ä¸è¶³
}
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// å¢åŠ ç¯å¢ƒéšæœºæ€§
public VLAState reset() {
    // éšæœºåŒ–ç‰©ä½“ä½ç½®
    double[] objectPos = randomPosition();
    
    // éšæœºåŒ–ç‰©ä½“å±æ€§
    double mass = random.nextDouble() * 0.5 + 0.5;  // [0.5, 1.0]
    double friction = random.nextDouble() * 0.5 + 0.3;  // [0.3, 0.8]
    
    // éšæœºåŒ–è§†è§‰åœºæ™¯
    int lightingVariant = random.nextInt(5);
    String background = backgrounds[random.nextInt(backgrounds.length)];
    
    return createState(objectPos, mass, friction, lightingVariant, background);
}
```

---

#### åŸå› B: æ¨¡å‹å®¹é‡è¿‡å¤§

**è¯Šæ–­**:
```java
// ç»Ÿè®¡æ¨¡å‹å‚æ•°é‡
public long countParameters(VLAAgent agent) {
    long totalParams = 0;
    for (Parameter param : agent.parameters()) {
        totalParams += param.size();
    }
    System.out.println("Total parameters: " + totalParams);
    return totalParams;
}
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// å‡å°æ¨¡å‹è§„æ¨¡
VLAAgent smallerAgent = new VLAAgent(
    512,  // hiddenDim (åŸæ¥768)
    4,    // numHeads (åŸæ¥8)
    4,    // numLayers (åŸæ¥6)
    7     // actionDim
);

// æˆ–æ·»åŠ æ­£åˆ™åŒ–
config.setDropout(0.2);  // æ·»åŠ Dropout
config.setWeightDecay(1e-4);  // æ·»åŠ L2æ­£åˆ™åŒ–
```

---

## 2. æ¨ç†é—®é¢˜

### é—®é¢˜2.1: æ¨ç†ç»“æœä¸åˆç†

**ç—‡çŠ¶**:
```java
VLAAction action = agent.predict(state);
System.out.println("Action: " + action.getContinuousAction());
// è¾“å‡º: [NaN, NaN, NaN, ...]
// æˆ–: [1000.0, -500.0, 999.9, ...]  (å¼‚å¸¸å¤§çš„å€¼)
```

**å¯èƒ½åŸå› åŠè§£å†³æ–¹æ¡ˆ**:

#### åŸå› A: æ¨¡å‹æœªåŠ è½½æˆ–æŸå

**è¯Šæ–­**:
```java
// æ£€æŸ¥æ¨¡å‹æ˜¯å¦æ­£ç¡®åŠ è½½
public boolean checkModelLoaded(VLAAgent agent) {
    try {
        VLAState dummyState = createDummyState();
        VLAAction action = agent.predict(dummyState);
        
        // æ£€æŸ¥è¾“å‡ºæ˜¯å¦åˆç†
        if (action == null || action.hasNaN()) {
            System.err.println("Model output is invalid!");
            return false;
        }
        
        System.out.println("âœ“ Model loaded successfully");
        return true;
    } catch (Exception e) {
        System.err.println("âœ— Model loading failed: " + e.getMessage());
        return false;
    }
}
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// é‡æ–°åŠ è½½æ¨¡å‹
try {
    agent = VLAAgent.load("models/vla_model.pth");
    
    // éªŒè¯åŠ è½½
    if (!checkModelLoaded(agent)) {
        throw new RuntimeException("Model verification failed!");
    }
} catch (IOException e) {
    System.err.println("Failed to load model: " + e.getMessage());
    // å›é€€åˆ°å¤‡ä»½æ¨¡å‹
    agent = VLAAgent.load("models/vla_model_backup.pth");
}
```

---

#### åŸå› B: è¾“å…¥æ•°æ®æœªå½’ä¸€åŒ–

**è¯Šæ–­**:
```java
// æ£€æŸ¥è¾“å…¥æ•°æ®èŒƒå›´
public void diagnoseInput(VLAState state) {
    NdArray image = state.getVisionInput().getRgbImage();
    System.out.printf("Image range: [%.2f, %.2f]%n", 
        image.min(), image.max());
    // åº”è¯¥åœ¨[0, 1]æˆ–[-1, 1]èŒƒå›´å†…
    
    NdArray proprio = state.getProprioceptionInput().getJointPositions();
    System.out.printf("Proprio range: [%.2f, %.2f]%n",
        proprio.min(), proprio.max());
}
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// ç¡®ä¿è¾“å…¥å½’ä¸€åŒ–
public VLAState preprocessState(VLAState state) {
    // å½’ä¸€åŒ–å›¾åƒåˆ°[0, 1]
    NdArray image = state.getVisionInput().getRgbImage();
    image = image.div(NdArray.of(255.0));
    state.getVisionInput().setRgbImage(image);
    
    // å½’ä¸€åŒ–å…³èŠ‚è§’åº¦åˆ°[-1, 1]
    NdArray joints = state.getProprioceptionInput().getJointPositions();
    joints = normalizeJoints(joints);
    state.getProprioceptionInput().setJointPositions(joints);
    
    return state;
}
```

---

### é—®é¢˜2.2: æ¨ç†å»¶è¿Ÿè¿‡é«˜

**ç—‡çŠ¶**:
```
Inference time: 250ms per prediction
(Expected: <50ms)
```

**å¯èƒ½åŸå› åŠè§£å†³æ–¹æ¡ˆ**:

#### åŸå› A: æœªä½¿ç”¨æ‰¹å¤„ç†

**è¯Šæ–­**:
```java
// æµ‹é‡å•ä¸ªvsæ‰¹é‡æ¨ç†æ—¶é—´
long start = System.nanoTime();
for (int i = 0; i < 32; i++) {
    agent.predict(states.get(i));
}
long singleTime = System.nanoTime() - start;

start = System.nanoTime();
agent.batchPredict(states);
long batchTime = System.nanoTime() - start;

System.out.printf("Single: %dms, Batch: %dms, Speedup: %.1fx%n",
    singleTime / 1_000_000, batchTime / 1_000_000,
    (double) singleTime / batchTime);
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// ä½¿ç”¨æ‰¹å¤„ç†æ¨ç†
List<VLAState> stateBatch = new ArrayList<>();

// æ”¶é›†æ‰¹æ¬¡
for (RobotEnvironment env : environments) {
    stateBatch.add(env.getCurrentState());
}

// æ‰¹é‡æ¨ç†
List<VLAAction> actions = agent.batchPredict(stateBatch);

// åˆ†å‘åŠ¨ä½œ
for (int i = 0; i < environments.size(); i++) {
    environments.get(i).step(actions.get(i));
}
```

---

#### åŸå› B: é‡å¤ç¼–ç 

**è¯Šæ–­**:
```java
// åˆ†ææ¨ç†æ—¶é—´åˆ†å¸ƒ
Profiler profiler = new Profiler();

profiler.start("vision_encoding");
NdArray visionFeatures = visionEncoder.encode(visionInput);
profiler.stop("vision_encoding");

profiler.start("language_encoding");
NdArray languageFeatures = languageEncoder.encode(languageInput);
profiler.stop("language_encoding");

profiler.start("action_decoding");
VLAAction action = actionDecoder.decode(fusedFeatures);
profiler.stop("action_decoding");

profiler.printStats();
// å¦‚æœlanguage_encodingå ç”¨>30%æ—¶é—´ï¼Œè€ƒè™‘ç¼“å­˜
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// ç¼“å­˜è¯­è¨€ç‰¹å¾ï¼ˆæŒ‡ä»¤é€šå¸¸ä¸å˜ï¼‰
private NdArray cachedLanguageFeatures = null;
private String cachedInstruction = null;

public VLAAction predict(VLAState state) {
    String instruction = state.getLanguageInput().getInstruction();
    
    // å¦‚æœæŒ‡ä»¤æœªå˜ï¼Œå¤ç”¨ç¼“å­˜
    if (instruction.equals(cachedInstruction)) {
        languageFeatures = cachedLanguageFeatures;
    } else {
        languageFeatures = languageEncoder.encode(instruction);
        cachedLanguageFeatures = languageFeatures;
        cachedInstruction = instruction;
    }
    
    // ... åç»­å¤„ç†
}
```

---

## 3. æ€§èƒ½é—®é¢˜

### é—®é¢˜3.1: GPUå†…å­˜æº¢å‡º

**ç—‡çŠ¶**:
```
OutOfMemoryError: Java heap space
æˆ–
CUDA out of memory
```

**å¯èƒ½åŸå› åŠè§£å†³æ–¹æ¡ˆ**:

#### åŸå› A: æ‰¹æ¬¡å¤§å°è¿‡å¤§

**è¯Šæ–­**:
```java
// æµ‹è¯•ä¸åŒæ‰¹æ¬¡å¤§å°çš„å†…å­˜ä½¿ç”¨
Runtime runtime = Runtime.getRuntime();

for (int batchSize : new int[]{8, 16, 32, 64, 128}) {
    runtime.gc();
    long before = runtime.totalMemory() - runtime.freeMemory();
    
    try {
        List<VLAState> batch = createBatch(batchSize);
        agent.batchPredict(batch);
        
        long after = runtime.totalMemory() - runtime.freeMemory();
        long used = (after - before) / 1024 / 1024;  // MB
        
        System.out.printf("Batch size %d: %d MB%n", batchSize, used);
    } catch (OutOfMemoryError e) {
        System.out.printf("Batch size %d: OOM!%n", batchSize);
        break;
    }
}
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// å‡å°æ‰¹æ¬¡å¤§å°
config.setBatchSize(16);  // åŸæ¥æ˜¯64

// æˆ–ä½¿ç”¨æ¢¯åº¦æ£€æŸ¥ç‚¹ï¼ˆè®­ç»ƒæ—¶ï¼‰
agent.enableGradientCheckpointing(true);
```

---

#### åŸå› B: è®¡ç®—å›¾æœªé‡Šæ”¾

**è¯Šæ–­**:
```java
// æ£€æŸ¥æ˜¯å¦æœ‰å†…å­˜æ³„æ¼
for (int i = 0; i < 100; i++) {
    agent.predict(state);
    
    if (i % 10 == 0) {
        Runtime runtime = Runtime.getRuntime();
        long used = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024;
        System.out.printf("Iteration %d: %d MB%n", i, used);
        // å¦‚æœå†…å­˜æŒç»­å¢é•¿ï¼Œè¯´æ˜æœ‰æ³„æ¼
    }
}
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// æ¨ç†æ—¶ä¸æ„å»ºè®¡ç®—å›¾
agent.eval();  // è®¾ç½®ä¸ºè¯„ä¼°æ¨¡å¼

// æˆ–æ˜¾å¼é‡Šæ”¾
public VLAAction predict(VLAState state) {
    try {
        return agent.forward(state);
    } finally {
        // é‡Šæ”¾ä¸­é—´å˜é‡
        agent.clearIntermediateVariables();
    }
}
```

---

### é—®é¢˜3.2: CPUä½¿ç”¨ç‡ä½

**ç—‡çŠ¶**:
```
CPUä½¿ç”¨ç‡: 15% (8æ ¸å¿ƒå¹³å‡)
è®­ç»ƒé€Ÿåº¦æ…¢ï¼Œä½†CPUå’ŒGPUéƒ½æ²¡æœ‰æ»¡è½½
```

**å¯èƒ½åŸå› åŠè§£å†³æ–¹æ¡ˆ**:

#### åŸå› A: æ•°æ®åŠ è½½ç“¶é¢ˆ

**è¯Šæ–­**:
```java
// æµ‹é‡æ•°æ®åŠ è½½æ—¶é—´
long totalDataTime = 0;
long totalTrainTime = 0;

for (int i = 0; i < 100; i++) {
    long start = System.nanoTime();
    VLAState state = env.reset();
    totalDataTime += System.nanoTime() - start;
    
    start = System.nanoTime();
    learner.trainEpisode(agent, env);
    totalTrainTime += System.nanoTime() - start;
}

System.out.printf("Data loading: %.1f%%, Training: %.1f%%%n",
    totalDataTime * 100.0 / (totalDataTime + totalTrainTime),
    totalTrainTime * 100.0 / (totalDataTime + totalTrainTime));
// å¦‚æœæ•°æ®åŠ è½½>30%ï¼Œéœ€è¦ä¼˜åŒ–
```

**è§£å†³æ–¹æ¡ˆ**:
```java
// ä½¿ç”¨å¤šçº¿ç¨‹æ•°æ®åŠ è½½
ExecutorService dataLoader = Executors.newFixedThreadPool(4);

List<Future<VLAState>> futures = new ArrayList<>();
for (int i = 0; i < batchSize; i++) {
    futures.add(dataLoader.submit(() -> env.reset()));
}

// æ”¶é›†ç»“æœ
List<VLAState> batch = futures.stream()
    .map(f -> {
        try {
            return f.get();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    })
    .collect(Collectors.toList());
```

---

## 4. å†…å­˜é—®é¢˜

### é—®é¢˜4.1: å†…å­˜æ³„æ¼

**ç—‡çŠ¶**:
```
è®­ç»ƒå¼€å§‹: 2GB
è®­ç»ƒ1å°æ—¶: 6GB
è®­ç»ƒ2å°æ—¶: 10GB
è®­ç»ƒ3å°æ—¶: 14GB -> OOM
```

**è¯Šæ–­æ­¥éª¤**:

```java
// 1. å¯ç”¨å†…å­˜ç›‘æ§
public class MemoryMonitor {
    private static final Runtime runtime = Runtime.getRuntime();
    
    public static void logMemory(String tag) {
        long used = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024;
        long max = runtime.maxMemory() / 1024 / 1024;
        System.out.printf("[%s] Memory: %d / %d MB (%.1f%%)%n",
            tag, used, max, used * 100.0 / max);
    }
}

// 2. åœ¨å…³é”®ä½ç½®ç›‘æ§
MemoryMonitor.logMemory("Before episode");
learner.trainEpisode(agent, env);
MemoryMonitor.logMemory("After episode");

runtime.gc();
MemoryMonitor.logMemory("After GC");
```

**å¸¸è§æ³„æ¼ç‚¹**:

```java
// âœ— æ³„æ¼ç‚¹1: ç¼“å­˜æ— é™å¢é•¿
private Map<String, NdArray> cache = new HashMap<>();  // ä»ä¸æ¸…ç†

// âœ“ è§£å†³æ–¹æ¡ˆ: ä½¿ç”¨LRUç¼“å­˜
private LinkedHashMap<String, NdArray> cache = new LinkedHashMap<>(100, 0.75f, true) {
    @Override
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > 100;  // æœ€å¤šä¿ç•™100é¡¹
    }
};

// âœ— æ³„æ¼ç‚¹2: ç›‘å¬å™¨æœªç§»é™¤
env.addListener(listener);  // ä»ä¸removeListener

// âœ“ è§£å†³æ–¹æ¡ˆ: ä½¿ç”¨try-finally
Listener listener = new MyListener();
try {
    env.addListener(listener);
    // è®­ç»ƒé€»è¾‘
} finally {
    env.removeListener(listener);
}

// âœ— æ³„æ¼ç‚¹3: è®¡ç®—å›¾æœªé‡Šæ”¾
Variable result = agent.forward(input);  // ä¿ç•™äº†æ•´ä¸ªè®¡ç®—å›¾

// âœ“ è§£å†³æ–¹æ¡ˆ: åŠæ—¶é‡Šæ”¾
Variable result = agent.forward(input);
try {
    // ä½¿ç”¨result
} finally {
    result.clearGrad();
    result.unchain();  // åˆ‡æ–­è®¡ç®—å›¾
}
```

---

## 5. æ•°æ®é—®é¢˜

### é—®é¢˜5.1: æ•°æ®åˆ†å¸ƒä¸å¹³è¡¡

**ç—‡çŠ¶**:
```
æˆåŠŸæ ·æœ¬: 5%
å¤±è´¥æ ·æœ¬: 95%
æ¨¡å‹å­¦ä¼šäº†æ€»æ˜¯é¢„æµ‹å¤±è´¥
```

**è¯Šæ–­**:
```java
// ç»Ÿè®¡æ•°æ®åˆ†å¸ƒ
public void analyzeDataDistribution(List<EpisodeData> episodes) {
    int successCount = 0;
    int failCount = 0;
    
    for (EpisodeData episode : episodes) {
        if (episode.isSuccess()) {
            successCount++;
        } else {
            failCount++;
        }
    }
    
    double successRate = successCount * 100.0 / episodes.size();
    System.out.printf("Success: %d (%.1f%%), Fail: %d (%.1f%%)%n",
        successCount, successRate, failCount, 100 - successRate);
    
    if (successRate < 20 || successRate > 80) {
        System.err.println("WARNING: Data is imbalanced!");
    }
}
```

**è§£å†³æ–¹æ¡ˆ**:

```java
// æ–¹æ¡ˆ1: è¿‡é‡‡æ ·å°‘æ•°ç±»
public List<EpisodeData> balanceData(List<EpisodeData> episodes) {
    List<EpisodeData> successEpisodes = episodes.stream()
        .filter(EpisodeData::isSuccess)
        .collect(Collectors.toList());
    
    List<EpisodeData> failEpisodes = episodes.stream()
        .filter(e -> !e.isSuccess())
        .collect(Collectors.toList());
    
    // é‡å¤é‡‡æ ·æˆåŠŸæ ·æœ¬
    int targetCount = failEpisodes.size();
    List<EpisodeData> balanced = new ArrayList<>(failEpisodes);
    
    Random random = new Random();
    while (balanced.size() < targetCount * 2) {
        balanced.add(successEpisodes.get(random.nextInt(successEpisodes.size())));
    }
    
    Collections.shuffle(balanced);
    return balanced;
}

// æ–¹æ¡ˆ2: åŠ æƒæŸå¤±
public double computeWeightedLoss(VLAAction predicted, VLAAction actual, boolean isSuccess) {
    double loss = computeLoss(predicted, actual);
    
    // æˆåŠŸæ ·æœ¬æƒé‡æ›´é«˜
    double weight = isSuccess ? 2.0 : 1.0;
    
    return loss * weight;
}
```

---

## 6. ç¯å¢ƒé—®é¢˜

### é—®é¢˜6.1: ç¯å¢ƒåˆå§‹åŒ–å¤±è´¥

**ç—‡çŠ¶**:
```
Exception in thread "main" NullPointerException
at SimpleRobotEnv.reset(SimpleRobotEnv.java:45)
```

**è¯Šæ–­å’Œè§£å†³**:

```java
// æ·»åŠ è¯¦ç»†çš„é”™è¯¯æ£€æŸ¥
public VLAState reset() {
    try {
        // æ£€æŸ¥é…ç½®
        if (taskConfig == null) {
            throw new IllegalStateException("TaskConfig not set!");
        }
        
        // æ£€æŸ¥å·¥ä½œç©ºé—´
        if (workspace == null || workspace.isEmpty()) {
            throw new IllegalStateException("Workspace not initialized!");
        }
        
        // åˆå§‹åŒ–çŠ¶æ€
        VLAState state = initializeState();
        
        // éªŒè¯çŠ¶æ€
        if (!validateState(state)) {
            throw new IllegalStateException("Invalid initial state!");
        }
        
        return state;
        
    } catch (Exception e) {
        System.err.println("Environment reset failed:");
        e.printStackTrace();
        
        // å°è¯•æ¢å¤
        return createDefaultState();
    }
}

// çŠ¶æ€éªŒè¯
private boolean validateState(VLAState state) {
    if (state == null) return false;
    
    if (state.getVisionInput() == null) {
        System.err.println("Vision input is null!");
        return false;
    }
    
    if (state.getLanguageInput() == null) {
        System.err.println("Language input is null!");
        return false;
    }
    
    return true;
}
```

---

## 7. éƒ¨ç½²é—®é¢˜

### é—®é¢˜7.1: æ¨¡å‹åŠ è½½å¤±è´¥

**ç—‡çŠ¶**:
```
Failed to load model: File not found
æˆ–
Model version mismatch
```

**è§£å†³æ–¹æ¡ˆ**:

```java
public VLAAgent loadModelSafely(String modelPath) {
    // 1. æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    File modelFile = new File(modelPath);
    if (!modelFile.exists()) {
        System.err.println("Model file not found: " + modelPath);
        
        // å°è¯•ä»å¤‡ä»½ä½ç½®åŠ è½½
        String backupPath = modelPath.replace(".pth", "_backup.pth");
        if (new File(backupPath).exists()) {
            System.out.println("Loading from backup: " + backupPath);
            return loadModelSafely(backupPath);
        }
        
        throw new FileNotFoundException("No model file found");
    }
    
    // 2. æ£€æŸ¥æ¨¡å‹ç‰ˆæœ¬
    ModelMetadata metadata = readMetadata(modelPath);
    if (!isCompatible(metadata)) {
        System.err.println("Model version incompatible!");
        System.err.println("Model version: " + metadata.getVersion());
        System.err.println("Required version: " + CURRENT_VERSION);
        
        throw new IllegalStateException("Version mismatch");
    }
    
    // 3. åŠ è½½æ¨¡å‹
    try {
        VLAAgent agent = VLAAgent.load(modelPath);
        
        // 4. éªŒè¯æ¨¡å‹
        if (!verifyModel(agent)) {
            throw new IllegalStateException("Model verification failed");
        }
        
        System.out.println("âœ“ Model loaded successfully");
        return agent;
        
    } catch (Exception e) {
        System.err.println("Failed to load model: " + e.getMessage());
        throw new RuntimeException(e);
    }
}
```

---

## 8. æ—¥å¿—åˆ†æ

### 8.1 æ—¥å¿—çº§åˆ«è®¾ç½®

```java
// æ¨èçš„æ—¥å¿—é…ç½®
public class VLALogger {
    private static final Logger logger = Logger.getLogger("VLA");
    
    static {
        // å¼€å‘ç¯å¢ƒï¼šDEBUG
        // ç”Ÿäº§ç¯å¢ƒï¼šINFO
        logger.setLevel(Level.INFO);
        
        // æ§åˆ¶å°è¾“å‡º
        ConsoleHandler console = new ConsoleHandler();
        console.setLevel(Level.INFO);
        logger.addHandler(console);
        
        // æ–‡ä»¶è¾“å‡º
        try {
            FileHandler file = new FileHandler("vla_%g.log", 10_000_000, 10);
            file.setLevel(Level.ALL);
            logger.addHandler(file);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    public static void logTrainingStep(int episode, double reward, double loss) {
        logger.info(String.format("Episode %d - Reward: %.2f, Loss: %.4f",
            episode, reward, loss));
    }
    
    public static void logError(String message, Exception e) {
        logger.log(Level.SEVERE, message, e);
    }
}
```

---

### 8.2 å…³é”®æŒ‡æ ‡ç›‘æ§

```java
public class MetricsCollector {
    private Map<String, List<Double>> metrics = new HashMap<>();
    
    public void record(String name, double value) {
        metrics.computeIfAbsent(name, k -> new ArrayList<>()).add(value);
    }
    
    public void printSummary() {
        System.out.println("=== Metrics Summary ===");
        
        for (Map.Entry<String, List<Double>> entry : metrics.entrySet()) {
            String name = entry.getKey();
            List<Double> values = entry.getValue();
            
            double mean = values.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
            double std = calculateStd(values);
            double min = values.stream().mapToDouble(Double::doubleValue).min().orElse(0.0);
            double max = values.stream().mapToDouble(Double::doubleValue).max().orElse(0.0);
            
            System.out.printf("%s: Î¼=%.2f, Ïƒ=%.2f, min=%.2f, max=%.2f%n",
                name, mean, std, min, max);
        }
    }
}
```

---

## ğŸ“ è·å–å¸®åŠ©

å¦‚æœæœ¬æ‰‹å†Œæœªèƒ½è§£å†³æ‚¨çš„é—®é¢˜ï¼Œè¯·ï¼š

1. **æŸ¥çœ‹æŠ€æœ¯æ–‡æ¡£**: [æŠ€æœ¯æ¶æ„æ–‡æ¡£](æŠ€æœ¯æ¶æ„æ–‡æ¡£.md)
2. **å‚è€ƒæœ€ä½³å®è·µ**: [æœ€ä½³å®è·µæŒ‡å—](æœ€ä½³å®è·µæŒ‡å—.md)
3. **æäº¤Issue**: https://github.com/TinyAI/issues
4. **ç¤¾åŒºè®¨è®º**: https://discuss.tinyai.io

---

**ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¶é—´**: 2025-10-18  
**ç»´æŠ¤è€…**: TinyAI VLA Team

*æŒç»­æ›´æ–°ä¸­ï¼Œæ¬¢è¿åé¦ˆï¼*
